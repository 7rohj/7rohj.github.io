---
emoji: 📓
title: Hash Table에 대해서 완전 자세하게 알아보자.
date: '2022-04-01 00:00:00'
author: weasel
tags: 자료구조 hashtable
categories: 자료구조
---
내부적으로 배열을 사용하여 조회,삽입,삭제 모두 `O(1)`안에 수행하기 위한 특별한 자료구조다. 배열의 인덱스를 유일하게(혹은 그에 가깝게) 지정하기 위해서 데이터와 연관된 고유한 숫자를 만들어낸 후 그것을 인덱스로 사용한다.

또 일반적으로 순서를 보장하지 않기 때문에, 순서, 관계가 있는 목적에는 적합하지 않다.

## Hash funciton

데이터에 연관된 고유한 값을 만들기 위해서 해시 함수를 사용한다. 이 해시 함수를 통해서 나온 결과값을 해시 값(혹은 해쉬 코드,해쉬)라고 하고 이것을 이용해 데이터에 대한 접근 연산을 수행한다.

가장 많이 쓰이는 해시 함수는 나머지 연산(modulo)를 이용한다. 키 `k` 를 어떤 정해진 수 `D` 로 나눈 나머지를 `k` 를 저장하는 버킷의 인덱스로 사용하는 것이다. 
→ `h(k)=k`

일반적으로 `D` 는 적절히 큰 소수(prime number)를 사용하는데 이유는 다음과 같다. 
>만약 D를 소수가 아닌 값이라 하면, D의 모든 약수는 자신의 배수가 곧 키값이 된다. 해시충돌이 많이  일어나는것이다.

만약 이 해시 함수가 엄밀하지 못해서 **여러개의 객체가 서로 같은 값을 가지게 된다면 이것을 해시 충돌(hash collision)이라고 한다**. 

일반적인 경우에서 가능한 키들의 집합을 `U`라고 하고, 버킷들의 개수를 `m`이라고 할때 `U>>m`인 경우가 대부분이므로 충돌은 필연적으로 발생한다. 이것을 해결하기 위해서 버킷의 사이즈를 단순히 키우는것은 좋은 해결책이 아니다. 메모리 사용량에서 치명적이다.

좋은 해시 함수를 고안해도, **여전히 해시 충돌은 불가피하다**. 해시충돌이 늘어나게되면 `O(1)`의 시간복잡도 장점을 잃어버리고 `O(n)`에 가깝게 되니, 적절한 해결책을 세워야 한다.

## Open Addressing
